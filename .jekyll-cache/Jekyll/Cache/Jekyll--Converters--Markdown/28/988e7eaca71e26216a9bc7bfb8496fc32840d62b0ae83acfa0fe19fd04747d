I"—Ô<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1521542737388&amp;di=ad51209bad2d2becb367d0e283956a9c&amp;imgtype=0&amp;src=http%3A%2F%2Fimgsrc.baidu.com%2Fimage%2Fc0%253Dshijue1%252C0%252C0%252C294%252C40%2Fsign%3D54b10aa88d44ebf8797c6c7cb190bd5f%2F1b4c510fd9f9d72a5f8823b6de2a2834359bbba8.jpg" alt="" />
ITæ˜¯ä¸€ä¸ªç¹è£çš„è¡Œä¸šï¼Œå¯„æ‰˜ç€æ— æ•°äººçš„æ¢¦æƒ³ï¼Œå……æ–¥ç€æ— æ•°çš„é€ æ¢¦ç¥è¯ã€‚<br />
ITæ˜¯ä¸€ä¸ªæ‚²å‚¬çš„è¡Œä¸šï¼Œå±‚å‡ºä¸ç©·çš„æ–°æ¦‚å¿µè®©äººåº”æ¥ä¸æš‡ï¼Œå‡ ä¹åªè¦æœ‰ä¸€å¤©ä¸å­¦ä¹ ï¼Œéƒ½å¯èƒ½è®©ä½ å¯é£Ÿä¸å®‰ã€‚</p>

<p>é‡å­è®¡ç®—æœºæ˜¯ä¸€ä¸ªç‚’çš„æ¯”è¾ƒçƒ­çš„æ¦‚å¿µï¼Œç›®å‰è¿˜å¤„äºä¸Šå‡æœŸï¼Œæ„Ÿè§‰ä¸Šå·²ç»åˆ°äº†çˆ†å‘çš„è¾¹ç¼˜ï¼Œä¼¼ä¹éšæ—¶å¯ä»¥å‘¼ä¹‹æ¬²å‡ºã€‚<br />
é€šå¸¸å¯¹äºé‡å­è®¡ç®—æœºçš„ç†è§£å°±æ˜¯ï¼Œå› ä¸ºé‡å­è®¡ç®—æœºçš„å­˜å‚¨ç‰¹å¾ï¼Œå¯ä»¥å¤„ç†å¾ˆå¤§çš„æ•°æ®ï¼Œè€Œä¸æ˜¯åƒä¼ ç»Ÿè®¡ç®—æœºé‚£æ ·åªæ˜¯å¤„ç†1ã€0äºŒè¿›åˆ¶æ•°ï¼Œå› æ­¤è®¡ç®—æ•ˆç‡æ›´é«˜ã€‚ä»è€Œæœ‰å¯èƒ½é¢ è¦†ç°æœ‰çš„è®¡ç®—æœºæ¶æ„ï¼Œç”šè‡³ç°æœ‰çš„æ‰€æœ‰çš„åŠ å¯†ç®—æ³•ï¼Œå› ä¸ºæ–°çš„ã€é«˜é€Ÿçš„é‡å­è®¡ç®—æœºçš„å‡ºç°ï¼Œéƒ½å°†å› ä¸ºå¯èƒ½ä¼šè¢«å¿«é€Ÿçš„è§£å¯†è€Œå¤±å»æ•ˆç”¨ã€‚<br />
è¿™ä¸ªæ¦‚å¿µå¯¹ï¼Œä½†ä¹Ÿä¸å…¨å¯¹ï¼Œå¹¶ä¸”å¯èƒ½ä¸¢å¤±äº†å¾ˆå¤šé‡è¦çš„å†…å®¹ã€‚æ‰€ä»¥è¿™é‡Œè¯•å›¾æ›´é€šä¿—çš„è§£é‡Šä¸€ç•ªã€‚</p>

<h4 id="ä¼ ç»Ÿè®¡ç®—æœº">ä¼ ç»Ÿè®¡ç®—æœº</h4>
<p>è¯´é‡å­è®¡ç®—ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆè¦çœ‹ä¸€ä¸‹ä¼ ç»Ÿçš„è®¡ç®—æœºæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
ä½“ç³»ç»“æ„ã€ç¡¬ç›˜ã€å†…å­˜ã€CPUå•¥çš„å°±ä¸ç”¨è¯´äº†ï¼Œå¯¹äºè®¡ç®—æœ¬èº«æ¥è¯´ï¼Œè¿™äº›ä½“ç°ä¸å‡ºæ¥ä»€ä¹ˆä¸åŒã€‚<br />
æˆ‘ä»¬è¦ä»CPUæ¥è§£æï¼Œå½“å‰ä¸ç®¡å¤šä¹ˆå¤æ‚çš„è®¡ç®—æœºï¼Œè®¡ç®—çš„æ ¹æœ¬æ¥è‡ªäºä¸¤ä¸ªéƒ¨ä»¶ï¼š<br />
<strong>å¯„å­˜å™¨</strong> ï¼šç”¨äºå­˜å‚¨è®¡ç®—ç”¨çš„æ•°æ®ï¼ŒåŠè®¡ç®—çš„ç»“æœï¼Œæ¯”å¦‚å½“å‰çš„64ä½CPU,å…¶å®å°±ä»£è¡¨å¯„å­˜å™¨æ˜¯ç”±64ä½äºŒè¿›åˆ¶æ•°ç»„æˆçš„ã€‚<br />
<strong>é€»è¾‘é—¨</strong> ï¼šç”¨äºé€šè¿‡å„ç§å¤æ‚æ‹¼æ¥ã€ç»„åˆï¼Œä»è€Œå®Œæˆæ‰€éœ€çš„è®¡ç®—ã€‚å¸¸è§çš„é€»è¾‘æœ‰ï¼šä¸ã€æˆ–ã€éã€‚
ä¸‹é¢å¯¹åº”ä¼ ç»Ÿçš„è®¡ç®—æœºï¼Œæˆ‘ä»¬è¯´è¯´é‡å­è®¡ç®—æœºçš„çš„åŸç†ã€‚</p>

<h4 id="æµ‹é‡">æµ‹é‡</h4>
<p>å¯¹äºä¼ ç»Ÿè®¡ç®—æœºæ¥è®²ï¼Œæµ‹é‡å°±æ˜¯è¯»å–ï¼Œè¯»å–åˆæ˜¯æ‰€æœ‰è¿ç®—çš„åŸºç¡€ï¼ŒåŠŸèƒ½æ²¡å•¥å¥½å¤šè¯´çš„ï¼Œå°±æ˜¯çŸ¥é“å¯„å­˜å™¨ä¸­ä¿å­˜çš„æ•°å€¼æ˜¯ä»€ä¹ˆã€‚<br />
é‡å­è®¡ç®—æœºå°±å¤æ‚äº†ï¼Œä½ åº”å½“å¬è¯´è¿‡è–›å®šè°”çš„çŒ«ï¼ŒçŒ«æ”¾åœ¨ç®±å­é‡Œé¢ï¼Œç®±å­é‡Œé¢çš„æ”¾å°„æ€§å…ƒç´ æ˜¯å¦è¡°å˜å†³å®šç€çŒ«çš„æ­»æ´»ï¼Œä½†æ˜¯åœ¨ä½ æ‰“å¼€ç®±å­ä¹‹å‰ï¼Œä½ æ— æ³•ç¡®å®šï¼Œè€Œåœ¨æ‰“å¼€ç®±å­çš„ç¬é—´ï¼Œä½ å®é™…ä¹Ÿæ”¹å˜äº†ç®±å­çš„çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯å½±å“äº†çŒ«çš„ç”Ÿæ­»ï¼Œè¿™æ˜¯é‡å­ç‰©ç†é‡è¦çš„ä¸€ä¸ªç‰¹å¾ã€‚
è¿™ä¸ªç‰¹å¾äº§ç”Ÿäº†ä»¥ä¸‹å‡ ä¸ªé‡è¦çš„æ¦‚å¿µï¼Œæˆ–è€…è¯´é‡è¦çš„ç‰¹å¾ï¼Œè¿™äº›ç‰¹å¾å†³å®šäº†é‡å­è®¡ç®—æœºçš„å‡ ä¸ªé‡è¦åŠŸèƒ½ã€‚</p>

<h4 id="å åŠ æ€">å åŠ æ€</h4>
<p>ä¼ ç»Ÿçš„è®¡ç®—æœºï¼Œæ— è®ºæ˜¯å¯„å­˜å™¨è¿˜æ˜¯å­˜å‚¨å™¨ï¼Œå¾ˆé‡è¦çš„ä¸€ä¸ªæŒ‡æ ‡å°±æ˜¯ç¡®å®šæ€§æˆ–è€…è¯´ç¨³å®šæ€§ã€‚åœ¨å¯„å­˜å™¨æ–¹é¢ï¼Œå…¶ä¸­çš„æ¯ä¸€ä½(bit),å¯ä»¥ç¡®å®šæ˜¯1æˆ–è€…æ˜¯0ï¼Œ64ä½è®¡ç®—æœºï¼Œå¯„å­˜å™¨ä¿å­˜çš„æ•°å€¼æœ€å¤§æ˜¯2çš„64æ¬¡æ–¹ï¼ˆ2^64ï¼‰ã€‚<br />
é‡å­è®¡ç®—æœºé‡‡ç”¨å åŠ æ€åœ¨å¯„å­˜å™¨ä¸­ä¿å­˜æ•°æ®ï¼Œå› æ­¤åŒä¸€ä¸ªå¯„å­˜å™¨ï¼Œå¯èƒ½ä¿å­˜äº†å¤šä¸ªæ•°æ®ï¼Œè¿™å¯¼è‡´é‡å­å¯„å­˜å™¨å¯ä»¥ä¿å­˜çš„æ•°å€¼ï¼Œåœ¨åŒæ ·ä½æ•°ä¸‹ï¼Œæ¯”ä¼ ç»Ÿè®¡ç®—æœºä¿å­˜çš„æ•°æ®æ›´å¤šã€‚<br />
å½“å‰çš„é‡å­è®¡ç®—æœºï¼Œæ¯ä¸€ä½(bit),é€šè¿‡å åŠ æ€å¯ä»¥ä¿å­˜2å¯¹å¯ä»¥äº’ç›¸è½¬æ¢çš„çŠ¶æ€ï¼Œå¯ä»¥åˆ†åˆ«è¡¨ç¤ºä¸¤ä½äºŒè¿›åˆ¶æ•°å­—ã€‚å› ä¸ºä¸¤ä½äºŒè¿›åˆ¶æ•°å…±æœ‰4ä¸ªçŠ¶æ€ï¼Œå› æ­¤é‡å­è®¡ç®—æœºå¯„å­˜å™¨æŒ‡å®šä½é•¿ä¸‹ï¼Œå¯ä»¥æœ€å¤§è¡¨è¾¾4çš„Næ¬¡æ–¹(4^N)çš„æ•°å­—ã€‚<br />
è€ŒåŒæ—¶å› ä¸ºå åŠ æ€åŠå¯äº’ç›¸è½¬æ¢çš„ç‰¹å¾ï¼Œå®é™…ä¸Šæ¯ä¸ªæŒ‡å®šä½é•¿çš„å¯„å­˜å™¨ï¼Œéƒ½å¯èƒ½å­˜å‚¨2^Nä¸ªæ•°æ®ï¼Œè€Œä¸æ˜¯1ä¸ªï¼Œè¿™å°±æ˜¯é‡å­è®¡ç®—æœºçš„è¶…å¼ºå­˜å‚¨èƒ½åŠ›ï¼ˆæœ¬é¡¹èƒ½åŠ›åªæ˜¯åŸºäºç†è®ºè®¾æƒ³ï¼Œåœ¨å½“å‰çš„å„ç§é‡å­æœºå®ç°ä¸­ï¼Œè¿˜æ²¡æœ‰çœ‹åˆ°èµ„æ–™ä»‹ç»å®é™…çš„å®ç°ï¼‰ã€‚</p>

<h4 id="æ¦‚ç‡">æ¦‚ç‡</h4>
<p>å› ä¸ºå åŠ æ€å’Œæµ‹é‡ä¹Ÿä¼šå¯¹å…¶ä¸­æ•°å€¼é€ æˆçš„å½±å“ï¼Œå®é™…å…¶ä¸­çš„å€¼æ˜¯ç”±æ¦‚ç‡å†³å®šçš„ã€‚è¿™åœ¨é‡å­è®¡ç®—æœºçš„åˆ¶é€ å’Œç®—æ³•çš„ç ”ç©¶ä¸­ï¼Œéƒ½å¿…é¡»è€ƒè™‘åˆ°çš„é—®é¢˜ã€‚</p>

<h4 id="é‡å­å¯†ç ">é‡å­å¯†ç </h4>
<p>å› ä¸ºä¸å¯æµ‹çš„ç‰¹å¾å¸¦æ¥çš„æ— æ³•çªƒå¬å’Œä¸å¯å…‹éš†ç‰¹å¾ï¼Œå¼ºå¤§çš„é‡å­è®¡ç®—èƒ½åŠ›è™½ç„¶å¯¹ä¼ ç»Ÿçš„å¯†ç å­¦æ˜¯ä¸€ä¸ªç¾éš¾ï¼Œä½†åŒæ—¶ä¹Ÿä¼šå‡ºç°æ–°çš„ã€æ›´å¼ºå¤§çš„åŠ å¯†ç®—æ³•ã€‚ä»å…¬å¼€èµ„æ–™ä¸Šçœ‹ï¼Œæˆ‘ä»¬å›½å®¶æ‰€å®ç°çš„æ˜Ÿ-åœ°é‡å­é€šè®¯çš„ä¸»è¦åŸºç¡€å°±æ˜¯æ¥è‡ªäºæ­¤ã€‚</p>

<h4 id="å‘é‡è®¡ç®—å’Œå¹¶è¡Œè®¡ç®—">å‘é‡è®¡ç®—å’Œå¹¶è¡Œè®¡ç®—</h4>
<p>å› ä¸ºä¸Šé¢è¯´çš„å åŠ æ€çš„ä¸¤å¯¹çŠ¶æ€ï¼Œæ¯ä¸€ä¸ªè®¡ç®—å®é™…éƒ½è½¬æ¢ä¸ºäº†å‘é‡è¿ç®—ã€‚ç°åœ¨è®¡ç®—æœºä¸­æœ€è€—èƒ½çš„å‡ é¡¹è¿ç®—ï¼šæŒ–çŸ¿ã€å›¾å½¢å›¾åƒã€æ·±åº¦å­¦ä¹ ç­‰ï¼Œéƒ½æ˜¯è½¬æ¢æˆå‘é‡å’ŒçŸ©é˜µè¿›è¡Œè¿ç®—çš„ã€‚åœ¨ä¼ ç»Ÿçš„è®¡ç®—ä¸­ï¼Œå› ä¸ºäºŒè¿›åˆ¶çš„ç‰¹å¾ï¼Œä¸€èˆ¬å¤æ‚åº¦éƒ½æ˜¯O(2^N),è€Œåœ¨é‡å­è®¡ç®—æœºä¸­ï¼Œå› ä¸ºè¿™ç§ç‰¹å¾ï¼Œæ¯æ¬¡æ˜¯ä¸¤ä¸ªæ•°æ®å‚ä¸è¿ç®—ï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯O(N)ã€‚æ‰€ä»¥è¿ç®—é‡ä¸å†å‘ˆç°æŒ‡æ•°é£™å‡ï¼Œè€Œæ˜¯çº¿æ€§å¢åŠ ã€‚<br />
æ­¤å¤–ï¼Œå› ä¸ºå åŠ æ€çš„å­˜åœ¨ï¼Œæˆ‘ä»¬åœ¨é‡å­è¿ç®—ä¸­ï¼Œä¸å¿…åƒä¼ ç»Ÿè®¡ç®—ä¸€æ ·åŒæ—¶åªå¤„ç†ä¸€ä¸ªæ•°å€¼ï¼Œè€Œæ˜¯åŒæ—¶å¤„ç†å åŠ çš„å¤šä¸ªæ•°å€¼ï¼Œå®ç°äº†çœŸæ­£çš„å¹¶è¡Œè®¡ç®—ã€‚è€Œä¼ ç»Ÿè®¡ç®—ä¸­çš„å¹¶è¡Œï¼Œä¸è¿‡æ˜¯æŠŠå¤§çš„å¹¶è¡Œè½¬æ¢æˆå¤šä¸ªå°çš„æ—¶é—´ç‰‡å†ä¸²è¡Œè€Œå·²ã€‚è¿™æ›´è¿›ä¸€æ­¥çš„æé«˜äº†è¿ç®—èƒ½åŠ›ã€‚å½“ç„¶è¿™ä¹Ÿéœ€è¦æ›´å¤æ‚çš„å¹¶è¡Œç®—æ³•æ¥æ”¯æŒã€‚</p>

<h4 id="å•é‡å­æ¯”ç‰¹é—¨">å•é‡å­æ¯”ç‰¹é—¨</h4>
<p>å¦‚åŒä¼ ç»Ÿè®¡ç®—æœºä¸€æ ·ï¼Œé‡å­è®¡ç®—æœºä¹Ÿæ˜¯é€šè¿‡é€»è¾‘é—¨çš„è¿ç®—æ¥å®Œæˆå®é™…è¿ç®—çš„ã€‚<br />
åŒæ—¶å› ä¸ºä¸Šé¢è¯´è¿‡çš„é‚£äº›ç‰¹å¾ï¼Œå•é‡å­æ¯”ç‰¹é—¨ä¹Ÿæœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ç‰¹å¾ï¼š<strong>å¯é€†æ€§</strong>ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œä¼ ç»Ÿè®¡ç®—æœºçš„é€»è¾‘é—¨æ˜¯ä¸å¯é€†çš„ï¼Œè€Œå•é‡å­æ¯”ç‰¹é—¨çš„å„ç§è¿ç®—éƒ½å¯é€†ï¼›å¦å¤–ä¸€ä¸ªé‡è¦ç‰¹å¾å°±æ˜¯ä¸Šé¢è¯´è¿‡çš„ï¼š<strong>å¯å¹¶è¡Œ</strong>ã€‚<br />
è¿™äº›å¸¸ç”¨çš„é—¨ä¸­ï¼ŒåŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªï¼š<br />
<strong>Hadamard</strong>ï¼šæ—‹è½¬é—¨<br />
<strong>CNOT</strong>:å—æ§éé—¨ï¼Œå¦‚æœç¬¬ä¸€ä½ç½®1ï¼Œå€’ç½®ç¬¬äºŒä½ï¼Œå¦åˆ™ä¿æŒä¸å˜ã€‚<br />
<strong>Toffoli</strong>ï¼šæ§-æ§-éé—¨ï¼Œä¹Ÿå«CCNOTï¼Œå¦‚æœå‰ä¸¤ä½ç½®1ï¼Œå®ƒå°†å€’ç½®ç¬¬ä¸‰ä½ï¼Œå¦åˆ™æ‰€æœ‰ä½ä¿æŒä¸å˜<br />
<strong>noop</strong>ï¼šå•ä½é—¨ï¼Œç­‰äºä¸åšä»»ä½•æ“ä½œã€‚<br />
<strong>Xé—¨</strong>ï¼šæ±‚éå˜æ¢ï¼ŒNOTé—¨<br />
<strong>Zé—¨</strong>ï¼šç›¸ä½ç§»åŠ¨æ“ä½œ<br />
<strong>Yé—¨</strong>ï¼šç›¸å½“äºä¸Šé¢ä¸¤ä¸ªé—¨çš„ç»„åˆï¼ŒY=ZX</p>

<h4 id="é‡å­è®¡ç®—çš„æ¨¡æ‹Ÿ">é‡å­è®¡ç®—çš„æ¨¡æ‹Ÿ</h4>
<p>ç›®å‰çš„æƒ…å†µï¼Œé™¤éæ˜¯åœ¨ç›¸å…³å•ä½å·¥ä½œï¼Œå¦åˆ™ä¸€èˆ¬çš„å¼€å‘äººå‘˜å°šæ— æ³•äº²èº«ä½“éªŒé‡å­è®¡ç®—æœºã€‚æ›´è°ˆä¸ä¸Šå­¦ä¹ é‡å­è®¡ç®—æœºçš„å¼€å‘äº†ã€‚<br />
ä½†æ˜¯é€šè¿‡ä¸Šé¢çš„ä»‹ç»ä½ å¯ä»¥å‘ç°ï¼Œé™¤éåªåšä¸€ä¸ªæ‹¿æ¥ä¸»ä¹‰çš„ä½¿ç”¨è€…ï¼Œå¦åˆ™è¿™äº›é¢ è¦†æ€§çš„ç‰¹å¾å°†å¸¦æ¥ç®—æ³•ä¸Šçš„é‡å¤§æ”¹å˜ï¼Œä¸åŠæ—©çš„ç ”ç©¶ã€ç§¯ç´¯ï¼Œè¿™çœŸçš„å¯èƒ½æˆä¸ºç¨‹åºå‘˜çš„ä¸€ä¸ªâ€œç°çŠ€ç‰›â€ã€‚<br />
é™¤äº†åœ¨å®é™…çš„é‡å­è®¡ç®—æœºä¸Šå®éªŒï¼Œç›®å‰ä¹Ÿæœ‰å¾ˆå¤šè½¯ä»¶æä¾›äº†é‡å­è®¡ç®—çš„æ¨¡æ‹Ÿèƒ½åŠ›ï¼Œä»è€Œå¯ä»¥å°è¯•è‡ªå·±çš„ç®—æ³•å’Œå®éªŒï¼Œè¾¾åˆ°å­¦ä¹ çš„ç›®çš„ã€‚<br />
å¾®è½¯ç”šè‡³åˆ›ç«‹äº†ä¸€ç§æ–°çš„è¯­è¨€å«â€œQ#â€æ¥åº”å¯¹å°†æ¥çš„é‡å­è®¡ç®—ï¼Œç›¸ä¿¡åº”å½“ä¹Ÿä¸é”™ï¼Œä¸è¿‡æœ€è¿‘å¯¹äºéå¼€æºçš„é¡¹ç›®è¿˜æ˜¯æœ‰äº›éšœç¢ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¥å°è¯•å¦å¤–ä¸€ä¸ªå·¥å…·åº“DLIBã€‚</p>

<h4 id="ç¯å¢ƒæ­å»º">ç¯å¢ƒæ­å»º</h4>
<p>é¦–å…ˆè¦å‡è®¾ä½ å·²ç»æœ‰äº†åŸºæœ¬çš„å¼€å‘ç¯å¢ƒï¼Œæ¯”å¦‚g++/clangã€‚Ubuntuè¦ä¿è¯APTåŒ…ç®¡ç†çš„æ­£å¸¸ä½¿ç”¨ï¼ŒmacOSåˆ™é¢„å…ˆå®‰è£…å¥½HomebrewåŒ…ç®¡ç†ã€‚</p>

<p>åœ¨Ubuntu16ä¸Šï¼š</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>libdlib-dev
</code></pre></div></div>

<p>åœ¨macOSï¼š</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>dlib
</code></pre></div></div>

<h4 id="demoæºç ">DEMOæºç </h4>
<p>æœ¬æºç æ¥è‡ªDLIBçš„Examplesä»£ç quantum_computing_ex.cppï¼Œæœªåšä»»ä½•ä¿®æ”¹ã€‚<br />
ä»£ç ä¸­ä½¿ç”¨ä¸Šé¢ä»‹ç»è¿‡çš„è¿™å‡ ä¸ªé€»è¾‘é—¨ï¼Œå®ç°äº†ä¸¤ä¸ªæœ€å¸¸ç”¨çš„åŸºæœ¬ç®—æ³•ï¼šGrover Searchå’ŒShor ECCæ ¡éªŒã€‚è¿™ä¸¤ä¸ªç®—æ³•ä¹Ÿæ˜¯ç›¸å½“æœ‰åï¼Œç½‘ä¸Šä¸€æœèµ„æ–™å¤§æŠŠï¼Œæˆ‘è¿™åŠç“¶æ°´å°±ä¸ç”»è›‡æ·»è¶³äº†ã€‚</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The contents of this file are in the public domain. See LICENSE_FOR_EXAMPLE_PROGRAMS.txt</span>
<span class="cm">/*
    This is an example illustrating the use of the quantum computing
    simulation classes from the dlib C++ Library.

    This example assumes you are familiar with quantum computing and 
    Grover's search algorithm and Shor's 9 bit error correcting code
    in particular.   The example shows how to simulate both of these
    algorithms.


    The code to simulate Grover's algorithm is primarily here to show
    you how to make custom quantum gate objects.  The Shor ECC example
    is simpler and uses just the default gates that come with the 
    library.

*/</span>


<span class="cp">#include &lt;iostream&gt;
#include &lt;complex&gt;
#include &lt;ctime&gt;
#include &lt;dlib/quantum_computing.h&gt;
#include &lt;dlib/string.h&gt;
</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">dlib</span><span class="p">;</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>
<span class="c1">// ----------------------------------------------------------------------------------------</span>
<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="c1">// This declares a random number generator that we will be using below  </span>
<span class="n">dlib</span><span class="o">::</span><span class="n">rand</span> <span class="n">rnd</span><span class="p">;</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="kt">void</span> <span class="nf">shor_encode</span> <span class="p">(</span>
    <span class="n">quantum_register</span><span class="o">&amp;</span> <span class="n">reg</span>
<span class="p">)</span>
<span class="cm">/*!
    requires
        - reg.num_bits() == 1
    ensures
        - #reg.num_bits() == 9
        - #reg == the Shor error coding of the input register
!*/</span>
<span class="p">{</span>
    <span class="n">DLIB_CASSERT</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">num_bits</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="s">""</span><span class="p">);</span>

    <span class="n">quantum_register</span> <span class="n">zeros</span><span class="p">;</span>
    <span class="n">zeros</span><span class="p">.</span><span class="n">set_num_bits</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">zeros</span><span class="p">);</span>

    <span class="k">using</span> <span class="k">namespace</span> <span class="n">dlib</span><span class="o">::</span><span class="n">quantum_gates</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hadamard</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">noop</span><span class="p">();</span>

    <span class="c1">// Note that the expression (h,i) represents the tensor product of the 1 qubit </span>
    <span class="c1">// h gate with the 1 qubit i gate and larger versions of this expression </span>
    <span class="c1">// represent even bigger tensor products.  So as you see below, we make gates </span>
    <span class="c1">// big enough to apply to our quantum register by listing out all the gates we </span>
    <span class="c1">// want to go into the tensor product and then we just apply the resulting gate </span>
    <span class="c1">// to the quantum register.</span>

    <span class="c1">// Now apply the gates that constitute Shor's encoding to the input register.  </span>
    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
<span class="err">}</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="kt">void</span> <span class="nf">shor_decode</span> <span class="p">(</span>
    <span class="n">quantum_register</span><span class="o">&amp;</span> <span class="n">reg</span>
<span class="p">)</span>
<span class="cm">/*!
    requires
        - reg.num_bits() == 9
    ensures
        - #reg.num_bits() == 1
        - #reg == the decoded qubit that was in the given input register 
!*/</span>
<span class="p">{</span>
    <span class="n">DLIB_CASSERT</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">num_bits</span><span class="p">()</span> <span class="o">==</span> <span class="mi">9</span><span class="p">,</span><span class="s">""</span><span class="p">);</span>

    <span class="k">using</span> <span class="k">namespace</span> <span class="n">dlib</span><span class="o">::</span><span class="n">quantum_gates</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hadamard</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">noop</span><span class="p">();</span>

    <span class="c1">// Now apply the gates that constitute Shor's decoding to the input register</span>

    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="p">(</span><span class="n">toffoli</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">toffoli</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">toffoli</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">cnot</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="p">(</span><span class="n">toffoli</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="c1">// Now that we have decoded the value we don't need the extra 8 bits any more so </span>
    <span class="c1">// remove them from the register.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">reg</span><span class="p">.</span><span class="n">measure_and_remove_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">rnd</span><span class="p">);</span>
<span class="err">}</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>
<span class="c1">// ----------------------------------------------------------------------------------------</span>
<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="c1">// This is the function we will use in Grover's search algorithm.  In this</span>
<span class="c1">// case the value we are searching for is 257.</span>
<span class="kt">bool</span> <span class="nf">is_key</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">257</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">bits</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">uf_gate</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">dlib</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">bits</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">gate_traits</span><span class="o">&lt;</span><span class="n">uf_gate</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">num_bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">dlib</span><span class="o">::</span><span class="n">qc_helpers</span><span class="o">::</span><span class="n">exp_2_n</span><span class="o">&lt;</span><span class="n">num_bits</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">bits</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">uf_gate</span> <span class="o">:</span> <span class="k">public</span> <span class="n">gate_exp</span><span class="o">&lt;</span><span class="n">uf_gate</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="cm">/*!
        This gate represents the black box function in Grover's search algorithm.
        That is, it is the gate defined as follows:
            Uf|x&gt;|y&gt; = |x&gt;|y XOR is_key(x)&gt;

        See the documentation for the gate_exp object for the details regarding
        the compute_state_element() and operator() functions defined below.
    !*/</span>
<span class="nl">public:</span>
    <span class="n">uf_gate</span><span class="p">()</span> <span class="o">:</span> <span class="n">gate_exp</span><span class="o">&lt;</span><span class="n">uf_gate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">num_bits</span> <span class="o">=</span> <span class="n">gate_traits</span><span class="o">&lt;</span><span class="n">uf_gate</span><span class="o">&gt;::</span><span class="n">num_bits</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">gate_traits</span><span class="o">&lt;</span><span class="n">uf_gate</span><span class="o">&gt;::</span><span class="n">dims</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">qc_scalar_type</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">long</span> <span class="n">r</span><span class="p">,</span> <span class="kt">long</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span> 
    <span class="p">{</span> 
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">output</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="c1">// if the input control bit is set</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_key</span><span class="p">(</span><span class="n">output</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">^</span><span class="mh">0x1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">r</span> <span class="o">==</span> <span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">exp</span><span class="p">&gt;</span>
    <span class="n">qc_scalar_type</span> <span class="n">compute_state_element</span> <span class="p">(</span>
        <span class="k">const</span> <span class="n">matrix_exp</span><span class="o">&lt;</span><span class="n">exp</span><span class="o">&gt;&amp;</span> <span class="n">reg</span><span class="p">,</span>
        <span class="kt">long</span> <span class="n">row_idx</span>
    <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">output</span> <span class="o">=</span> <span class="n">row_idx</span><span class="p">;</span>
        <span class="c1">// if the input control bit is set</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_key</span><span class="p">(</span><span class="n">output</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">^</span><span class="mh">0x1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">reg</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">bits</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">w_gate</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">dlib</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">bits</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">gate_traits</span><span class="o">&lt;</span><span class="n">w_gate</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">num_bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">dlib</span><span class="o">::</span><span class="n">qc_helpers</span><span class="o">::</span><span class="n">exp_2_n</span><span class="o">&lt;</span><span class="n">num_bits</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">bits</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">w_gate</span> <span class="o">:</span> <span class="k">public</span> <span class="n">gate_exp</span><span class="o">&lt;</span><span class="n">w_gate</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="cm">/*!
        This is the W gate from the Grover algorithm
    !*/</span>
<span class="nl">public:</span>

    <span class="n">w_gate</span><span class="p">()</span> <span class="o">:</span> <span class="n">gate_exp</span><span class="o">&lt;</span><span class="n">w_gate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">num_bits</span> <span class="o">=</span> <span class="n">gate_traits</span><span class="o">&lt;</span><span class="n">w_gate</span><span class="o">&gt;::</span><span class="n">num_bits</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">gate_traits</span><span class="o">&lt;</span><span class="n">w_gate</span><span class="o">&gt;::</span><span class="n">dims</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">qc_scalar_type</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">long</span> <span class="n">r</span><span class="p">,</span> <span class="kt">long</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span> 
    <span class="p">{</span> 
        <span class="n">qc_scalar_type</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">/</span><span class="n">dims</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">res</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">exp</span><span class="p">&gt;</span>
    <span class="n">qc_scalar_type</span> <span class="n">compute_state_element</span> <span class="p">(</span>
        <span class="k">const</span> <span class="n">matrix_exp</span><span class="o">&lt;</span><span class="n">exp</span><span class="o">&gt;&amp;</span> <span class="n">reg</span><span class="p">,</span>
        <span class="kt">long</span> <span class="n">row_idx</span>
    <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">qc_scalar_type</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span><span class="o">/</span><span class="n">dims</span><span class="p">;</span>
        <span class="c1">// compute this value: temp = temp - reg(row_idx)*2.0/dims + reg(row_idx)*(2.0/dims - 1.0)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">-</span> <span class="n">reg</span><span class="p">(</span><span class="n">row_idx</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----------------------------------------------------------------------------------------</span>
<span class="c1">// ----------------------------------------------------------------------------------------</span>
<span class="c1">// ----------------------------------------------------------------------------------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// seed the random number generator</span>
    <span class="n">rnd</span><span class="p">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">cast_to_string</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>

    <span class="c1">// Pick out some of the gates we will be using below</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">dlib</span><span class="o">::</span><span class="n">quantum_gates</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">quantum_gates</span><span class="o">::</span><span class="n">hadamard</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">quantum_gates</span><span class="o">::</span><span class="n">z</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">quantum_gates</span><span class="o">::</span><span class="n">x</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">gate</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">quantum_gates</span><span class="o">::</span><span class="n">noop</span><span class="p">();</span>

    <span class="n">quantum_register</span> <span class="n">reg</span><span class="p">;</span>

    <span class="c1">// We will be doing the 12 qubit version of Grover's search algorithm.</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">bits</span><span class="o">=</span><span class="mi">12</span><span class="p">;</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">set_num_bits</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>


    <span class="c1">// set the quantum register to its initial state</span>
    <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="c1">// Print out the starting bits</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"starting bits: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">num_bits</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">probability_of_bit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


    <span class="c1">// Now apply the Hadamard gate to all the input bits</span>
    <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="c1">// Print out the status</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"after Hadamard gate: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">num_bits</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">probability_of_bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Here we do the grover iteration</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">35</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="n">uf_gate</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
        <span class="p">(</span><span class="n">w_gate</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>


        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">" probability: bit 1 = "</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">probability_of_bit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">", bit 9 = "</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">probability_of_bit</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Print out the final probability of measuring a 1 for each of the bits</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">num_bits</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"probability for bit "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">probability_of_bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The value we want grover's search to find is 257 which means we should measure a bit pattern of 00100000001"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Measured bits: "</span><span class="p">;</span>
    <span class="c1">// finally, measure all the bits and print out what they are.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">num_bits</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">measure_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">rnd</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    



    <span class="c1">// Now let's test out the Shor 9 bit encoding</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n\n\n</span><span class="s">Now let's try playing around with Shor's 9bit error correcting code"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Reset the quantum register to contain a single bit</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">set_num_bits</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// Set the state of this single qubit to some random mixture of the two computational bases</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">()(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">qc_scalar_type</span><span class="p">(</span><span class="n">rnd</span><span class="p">.</span><span class="n">get_random_double</span><span class="p">(),</span><span class="n">rnd</span><span class="p">.</span><span class="n">get_random_double</span><span class="p">());</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">()(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">qc_scalar_type</span><span class="p">(</span><span class="n">rnd</span><span class="p">.</span><span class="n">get_random_double</span><span class="p">(),</span><span class="n">rnd</span><span class="p">.</span><span class="n">get_random_double</span><span class="p">());</span>
    <span class="c1">// Make sure the state of the quantum register is a unit vector</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">()</span> <span class="o">/=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">())));</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"state: "</span> <span class="o">&lt;&lt;</span> <span class="n">trans</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">());</span>

    <span class="n">shor_encode</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x bit corruption on bit 8"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span> <span class="c1">// mess up the high order bit </span>
    <span class="n">shor_decode</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span> <span class="c1">// try to decode the register</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"state: "</span> <span class="o">&lt;&lt;</span> <span class="n">trans</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">());</span>

    <span class="n">shor_encode</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x bit corruption on bit 1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="n">shor_decode</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"state: "</span> <span class="o">&lt;&lt;</span> <span class="n">trans</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">());</span>

    <span class="n">shor_encode</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"z bit corruption on bit 8"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">).</span><span class="n">apply_gate_to</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
    <span class="n">shor_decode</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"state: "</span> <span class="o">&lt;&lt;</span> <span class="n">trans</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">state_vector</span><span class="p">());</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">The state of the input qubit survived all the corruptions in tact so the code works."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
<p>ç¼–è¯‘çš„æ–¹æ³•å¦‚ä¸‹ï¼š<br />
Ubuntu:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-std</span><span class="o">=</span>c++11 <span class="nt">-O3</span> <span class="nt">-o</span> quantum_computing_ex quantum_computing_ex.cpp <span class="nt">-l</span> dlib <span class="nt">-l</span> cblas
</code></pre></div></div>

<p>macOS:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-std</span><span class="o">=</span>c++11 <span class="nt">-O3</span> <span class="nt">-o</span> quantum_computing_ex quantum_computing_ex.cpp <span class="o">(</span>pkg-config <span class="nt">--cflags</span> <span class="nt">--libs</span> dlib-1<span class="o">)</span> <span class="nt">-l</span> cblas
</code></pre></div></div>

:ET