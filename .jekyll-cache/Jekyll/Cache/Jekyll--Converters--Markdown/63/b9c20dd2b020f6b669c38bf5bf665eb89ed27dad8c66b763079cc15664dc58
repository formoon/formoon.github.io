I"J�<p><img srchttp://blog.17study.com.cn/r/attachments/201904/tensorFlow2/tf-logo-card-2.png" alt="" /></p>
<h4 id="生成对抗网络的概念">生成对抗网络的概念</h4>
<p>上一篇中介绍的VAE自动编码器具备了一定程度的创造特征，能够“无中生有”的由一组随机数向量生成手写字符的图片。<br />
这个“创造能力”我们在模型中分为编码器和解码器两个部分。其能力来源实际上是大量样本经过学习编码后，在数字层面对编码结果进行微调，再解码生成图片的过程。所生成的图片，是对原样本图的某种变形模仿。</p>

<p>今天的要介绍的生成对抗网络(GAN)也具备很类似的功能，所建立的模型，能够生成非常接近样本图片的结果。<br />
相对于VAE，生成对抗网络GAN更接近一种思想，并非针对机器视觉领域，而是一种很通用的机器学习理念。</p>

<p>让我们用一个例子来理解生成对抗网络：<br />
比如我们想学习英语朗读。一开始，我们的朗读能力肯定很差，每次考试都是不及格。这时候，我们会努力的学习。当然人的学习是通过各种可能手段，听录音、看视频、找外教。学习一段时间后，再去参加考试，如果成绩依然很差，我们回来继续学习。一直到我们得到了一个自己满意的成绩。<br />
这个例子中有几个重要的因素：学习者本人就是机器学习中的神经网络，负责生成某个结果，比如朗读；考官负责判断我们朗读的英语是否达到了水平要求。考官实际也是一个网络模型，本身并不能知道什么样的朗读叫好，什么样的朗读叫差，其判断依据来自于对“好的朗读”样本的学习；学习者不断学习提高的过程，这个就相当于网络模型不断的训练迭代。</p>

<p>回到我们的图片生成过程。图片生成是一个模型，负责生成所需要的图片；<br />
<img src="/attachments/201904/tensorFlow2/gan-l1.png" alt="" /><br />
(图片来自官方文档)<br />
“考官”负责检查样本和生成图。这里有一个区别于VAE模型的重点，VAE是直接比较样本和生成图，以两者的差距作为代价。<br />
而GAN中，考官本身的学习，自动为样本图添加标注1，为生成图添加标注0。完成学习后，如果生成的图片，考官会判断为真实样本，说明所生成的图片达到了应有的水准。<br />
<img src="/attachments/201904/tensorFlow2/gan-l2.png" alt="" /><br />
（图片来自官方文档）<br />
这样的机器学习方式，可以不使用经过标注的样本数据，能够大量节省成本。虽然会带来学习过程的加长和大量算力需求，但通常来说，算力还是更容易获得的。<br />
另一个角度上说，VAE直接比较样本图片和生成图片，大量的数据和复杂性，导致VAE的损失函数的代码量大，计算速度也慢。GAN只有真、伪两个判断结果，模型输出简单，代价函数也容易的多。所以在同一组数据上，使用VAE算法往往会比GAN略慢一些。<br />
看起来如果只是生成图片这一个维度的结果，GAN似乎更有优势，但如果考虑到输出结果的可控性等因素，VAE在机器视觉领域的应用仍然是很广泛。<br />
不过GAN的思想是比较判断结果而非原图，是“裁判”，所以这种思想很容易推广到多个应用领域，而不仅仅是机器视觉范畴。</p>

<h4 id="gan实例">GAN实例</h4>
<p>本篇我们尝试使用时尚单品的样本库作为训练数据，最终让模型可以由随机的种子向量，生成时尚单品的图片。<br />
我们前面已经做过介绍，时尚单品的样本也是28x28单色图片，同MNIST手写数字样本是完全相同的格式。因此换用手写数字的图片样本，只要把载入样本数据的部分替换掉就可以，其它代码无需修改。<br />
<img src="/attachments/201904/tensorFlow2/fashion-mnist-sprite.png" alt="" /></p>

<p>样本数据载入的部分：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">train_images</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">fashion_mnist</span><span class="p">.</span><span class="n">load_data</span><span class="p">()</span>
</code></pre></div></div>
<p>我们实际只需要了训练的数据集，测试集和两个数据集的标注我们都直接抛弃了。GAN是典型的非监督学习，并不需要标注。</p>

<p>源码中方法make_generator_model用来建立图片生成模型；make_discriminator_model方法用来建立辨别模型，辨别模型也就是我们刚才说的“考官”。<br />
两个模型都使用keras.Sequential帮助建立，结构并不复杂。<br />
模型的学习一定要关注输入和输出，中间的部分如果没有理论基础，反而可以并不是很在意。因为算法的研究会关注模型，软件开发工程师更关心使用。</p>

<p>生成网络输入随机数种子向量序列，输出是28x28x1的图片序列。一次调用可以生成多幅图片。<br />
辨别模型输入是28x28x1的序列图片，输出只有1维。输出值接近0代表辨别结果是伪图片，输出值接近1表示辨别结果是真实样本图片。<br />
其中的卷积网络层，我们在上一个系列中做了仔细的介绍，这里可以再稍微复习一下关于卷积的输出维度。卷积层的输入必须是宽x高x色深的多维数组。输出的色深部分，同卷积层的节点数相同。宽、高则同卷积核的步长数相关，一般是乘的关系。比如：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">...</span><span class="n">假设本层输入为7x7x256</span><span class="p">...</span>
<span class="n">layers</span><span class="p">.</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="p">...</span><span class="n">因为节点数为128</span><span class="err">，</span><span class="n">步长是1</span><span class="p">...</span>
    <span class="p">...</span><span class="n">所以输出维度是7x7x128</span><span class="p">...</span>
<span class="n">layers</span><span class="p">.</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="p">...</span><span class="n">输出维度为14x14x64</span><span class="p">...</span>
</code></pre></div></div>
<p>使用Keras之后，这些细节一般都不需要自己去算了。但在这种图片作为输入、输出参数的模型中，为了保证结果图片是指定分辨率，这样的计算还是难以避免的。</p>

<p>两个模型分别使用两个不同的代价函数，生成模型的代价函数很简单。我们期望生成网络的图片，经过辨别模型后，结果无限接近1，也就是真实样本的水平：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 生成模型的损失函数
</span><span class="k">def</span> <span class="nf">generator_loss</span><span class="p">(</span><span class="n">fake_output</span><span class="p">):</span>
    <span class="c1"># 生成模型期望最终的结果越来越接近1，也就是真实样本
</span>    <span class="k">return</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">fake_output</span><span class="p">),</span> <span class="n">fake_output</span><span class="p">)</span>
</code></pre></div></div>
<p>辨别模型的代价函数，则是要对所有的样本图片人为指定标注结果是1，对所有生成的图片，则人为指定标注结果0。这目的是训练辨别模型对于辨别真伪的能力越来越强，从而可以判断生成的图片，是否能无限接近真实样本图片的水平。这个过程，其实就是“对抗”的过程。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 辨别模型损失函数
</span><span class="k">def</span> <span class="nf">discriminator_loss</span><span class="p">(</span><span class="n">real_output</span><span class="p">,</span> <span class="n">fake_output</span><span class="p">):</span>
    <span class="c1"># 样本图希望结果趋近1
</span>    <span class="n">real_loss</span> <span class="o">=</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">real_output</span><span class="p">),</span> <span class="n">real_output</span><span class="p">)</span>
    <span class="c1"># 自己生成的图希望结果趋近0
</span>    <span class="n">fake_loss</span> <span class="o">=</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fake_output</span><span class="p">),</span> <span class="n">fake_output</span><span class="p">)</span>
    <span class="c1"># 总损失
</span>    <span class="n">total_loss</span> <span class="o">=</span> <span class="n">real_loss</span> <span class="o">+</span> <span class="n">fake_loss</span>
    <span class="k">return</span> <span class="n">total_loss</span>
</code></pre></div></div>

<h4 id="完整源码">完整源码</h4>
<p>程序的其它部分，都同通常的机器学习项目非常类似，应当读起来没有难度了。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">imageio</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">PIL</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">layers</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># 如果使用train参数运行则进入训练模式
</span><span class="n">TRAIN</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'train'</span><span class="p">:</span>
    <span class="n">TRAIN</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1"># 使用手写字体样本做训练
# (train_images, _), (_, _) = keras.datasets.mnist.load_data()
# 使用时尚单品样本做训练
</span><span class="p">(</span><span class="n">train_images</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">fashion_mnist</span><span class="p">.</span><span class="n">load_data</span><span class="p">()</span>

<span class="c1"># 因为卷积层的需求，增加色深维度
</span><span class="n">train_images</span> <span class="o">=</span> <span class="n">train_images</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">train_images</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="s">'float32'</span><span class="p">)</span>
<span class="c1"># 规范化为-1 - +1
</span><span class="n">train_images</span> <span class="o">=</span> <span class="p">(</span><span class="n">train_images</span> <span class="o">-</span> <span class="mf">127.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">127.5</span>

<span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">60000</span>
<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">Dataset</span><span class="p">.</span><span class="n">from_tensor_slices</span><span class="p">(</span><span class="n">train_images</span><span class="p">).</span><span class="n">shuffle</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">).</span><span class="n">batch</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">)</span>

<span class="c1"># 图片生成模型
</span><span class="k">def</span> <span class="nf">make_generator_model</span><span class="p">():</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Sequential</span><span class="p">()</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="mi">7</span><span class="o">*</span><span class="mi">256</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,)))</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">BatchNormalization</span><span class="p">())</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">())</span>

    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Reshape</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">256</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">output_shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span> <span class="c1"># Note: None is the batch size
</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">output_shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>  
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">BatchNormalization</span><span class="p">())</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">())</span>

    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">output_shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>    
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">BatchNormalization</span><span class="p">())</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">())</span>

    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">output_shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model</span>

<span class="n">generator</span> <span class="o">=</span> <span class="n">make_generator_model</span><span class="p">()</span>

<span class="c1"># 原图、生成图辨别网络
</span><span class="k">def</span> <span class="nf">make_discriminator_model</span><span class="p">():</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Sequential</span><span class="p">()</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">,</span> 
                                     <span class="n">input_shape</span><span class="o">=</span><span class="p">[</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">())</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.3</span><span class="p">))</span>

    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">))</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">())</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.3</span><span class="p">))</span>

    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Flatten</span><span class="p">())</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">model</span>

<span class="n">discriminator</span> <span class="o">=</span> <span class="n">make_discriminator_model</span><span class="p">()</span>

<span class="c1"># 随机生成一个向量，用于生成图片
</span><span class="n">noise</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="c1"># 生成一张，此时模型未经训练，图片为噪点
</span><span class="n">generated_image</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="c1"># plt.imshow(generated_image[0, :, :, 0], cmap='gray')
# 判断结果
</span><span class="n">decision</span> <span class="o">=</span> <span class="n">discriminator</span><span class="p">(</span><span class="n">generated_image</span><span class="p">)</span>
<span class="c1"># 此时的结果应当应当趋近于0，表示为伪造图片
</span><span class="k">print</span><span class="p">(</span><span class="n">decision</span><span class="p">)</span>

<span class="c1"># 交叉熵损失函数
</span><span class="n">cross_entropy</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="n">BinaryCrossentropy</span><span class="p">(</span><span class="n">from_logits</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># 辨别模型损失函数
</span><span class="k">def</span> <span class="nf">discriminator_loss</span><span class="p">(</span><span class="n">real_output</span><span class="p">,</span> <span class="n">fake_output</span><span class="p">):</span>
    <span class="c1"># 样本图希望结果趋近1
</span>    <span class="n">real_loss</span> <span class="o">=</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">real_output</span><span class="p">),</span> <span class="n">real_output</span><span class="p">)</span>
    <span class="c1"># 自己生成的图希望结果趋近0
</span>    <span class="n">fake_loss</span> <span class="o">=</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fake_output</span><span class="p">),</span> <span class="n">fake_output</span><span class="p">)</span>
    <span class="c1"># 总损失
</span>    <span class="n">total_loss</span> <span class="o">=</span> <span class="n">real_loss</span> <span class="o">+</span> <span class="n">fake_loss</span>
    <span class="k">return</span> <span class="n">total_loss</span>

<span class="c1"># 生成模型的损失函数
</span><span class="k">def</span> <span class="nf">generator_loss</span><span class="p">(</span><span class="n">fake_output</span><span class="p">):</span>
    <span class="c1"># 生成模型期望最终的结果越来越接近1，也就是真实样本
</span>    <span class="k">return</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">fake_output</span><span class="p">),</span> <span class="n">fake_output</span><span class="p">)</span>

<span class="n">generator_optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="n">Adam</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">)</span>
<span class="n">discriminator_optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="n">Adam</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">)</span>

<span class="c1"># 训练结果保存
</span><span class="n">checkpoint_dir</span> <span class="o">=</span> <span class="s">'dcgan_training_checkpoints'</span>
<span class="n">checkpoint_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">checkpoint_dir</span><span class="p">,</span> <span class="s">"ckpt"</span><span class="p">)</span>
<span class="n">checkpoint</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">train</span><span class="p">.</span><span class="n">Checkpoint</span><span class="p">(</span><span class="n">generator_optimizer</span><span class="o">=</span><span class="n">generator_optimizer</span><span class="p">,</span>
                                 <span class="n">discriminator_optimizer</span><span class="o">=</span><span class="n">discriminator_optimizer</span><span class="p">,</span>
                                 <span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span>
                                 <span class="n">discriminator</span><span class="o">=</span><span class="n">discriminator</span><span class="p">)</span>

<span class="n">EPOCHS</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">noise_dim</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">num_examples_to_generate</span> <span class="o">=</span> <span class="mi">16</span>

<span class="c1"># 初始化16个种子向量，用于生成4x4的图片
</span><span class="n">seed</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">([</span><span class="n">num_examples_to_generate</span><span class="p">,</span> <span class="n">noise_dim</span><span class="p">])</span>

<span class="c1"># @tf.function表示TensorFlow编译、缓存此函数，用于在训练中快速调用
</span><span class="o">@</span><span class="n">tf</span><span class="p">.</span><span class="n">function</span>
<span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
    <span class="c1"># 随机生成一个批次的种子向量
</span>    <span class="n">noise</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">([</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">noise_dim</span><span class="p">])</span>

    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">gen_tape</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">disc_tape</span><span class="p">:</span>
        <span class="c1"># 生成一个批次的图片
</span>        <span class="n">generated_images</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c1"># 辨别一个批次的真实样本
</span>        <span class="n">real_output</span> <span class="o">=</span> <span class="n">discriminator</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># 辨别一个批次的生成图片
</span>        <span class="n">fake_output</span> <span class="o">=</span> <span class="n">discriminator</span><span class="p">(</span><span class="n">generated_images</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c1"># 计算两个损失值
</span>        <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">generator_loss</span><span class="p">(</span><span class="n">fake_output</span><span class="p">)</span>
        <span class="n">disc_loss</span> <span class="o">=</span> <span class="n">discriminator_loss</span><span class="p">(</span><span class="n">real_output</span><span class="p">,</span> <span class="n">fake_output</span><span class="p">)</span>

    <span class="c1"># 根据损失值调整模型的权重参量
</span>    <span class="n">gradients_of_generator</span> <span class="o">=</span> <span class="n">gen_tape</span><span class="p">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">gen_loss</span><span class="p">,</span> <span class="n">generator</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">gradients_of_discriminator</span> <span class="o">=</span> <span class="n">disc_tape</span><span class="p">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">disc_loss</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>

    <span class="c1"># 计算出的参量应用到模型
</span>    <span class="n">generator_optimizer</span><span class="p">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gradients_of_generator</span><span class="p">,</span> <span class="n">generator</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    <span class="n">discriminator_optimizer</span><span class="p">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gradients_of_discriminator</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>  
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">image_batch</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">train_step</span><span class="p">(</span><span class="n">image_batch</span><span class="p">)</span>

        <span class="c1"># 每个训练批次生成一张图片作为阶段成功
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"======================================="</span><span class="p">)</span>
        <span class="n">generate_and_save_images</span><span class="p">(</span>
            <span class="n">generator</span><span class="p">,</span>
            <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">)</span>

        <span class="c1"># 每20次迭代保存一次训练数据
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checkpoint</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_prefix</span><span class="o">=</span><span class="n">checkpoint_prefix</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">'Time for epoch {} is {} sec'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">generate_and_save_images</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">test_input</span><span class="p">):</span>
    <span class="c1"># 设置为非训练状态，生成一组图片
</span>    <span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">test_input</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

    <span class="c1"># 4格x4格拼接
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">predictions</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">127.5</span> <span class="o">+</span> <span class="mf">127.5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'gray'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>

    <span class="c1"># 保存为png
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">'image_at_epoch_{:04d}.png'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">))</span>
    <span class="c1"># plt.show()
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># 遍历所有png图片，汇总为gif动图
</span><span class="k">def</span> <span class="nf">write_gif</span><span class="p">():</span>
    <span class="n">anim_file</span> <span class="o">=</span> <span class="s">'dcgan.gif'</span>
    <span class="k">with</span> <span class="n">imageio</span><span class="p">.</span><span class="n">get_writer</span><span class="p">(</span><span class="n">anim_file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'I'</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'image*.png'</span><span class="p">)</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
        <span class="n">last</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filenames</span><span class="p">):</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">round</span><span class="p">(</span><span class="n">last</span><span class="p">):</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">frame</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">writer</span><span class="p">.</span><span class="n">append_data</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">append_data</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="c1"># 生成一张初始状态的4格图片，应当是噪点
</span><span class="n">generate_and_save_images</span><span class="p">(</span>
        <span class="n">generator</span><span class="p">,</span>
        <span class="mi">0000</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">)</span>

<span class="k">if</span> <span class="n">TRAIN</span><span class="p">:</span>
    <span class="c1"># 以训练模式运行，进入训练状态
</span>    <span class="n">train</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">EPOCHS</span><span class="p">)</span>
    <span class="n">write_gif</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># 非训练模式，恢复训练数据
</span>    <span class="n">checkpoint</span><span class="p">.</span><span class="n">restore</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">train</span><span class="p">.</span><span class="n">latest_checkpoint</span><span class="p">(</span><span class="n">checkpoint_dir</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"After training:"</span><span class="p">)</span>
    <span class="c1"># 显示训练完成后，生成图片的辨别结果
</span>    <span class="n">generated_image</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">decision</span> <span class="o">=</span> <span class="n">discriminator</span><span class="p">(</span><span class="n">generated_image</span><span class="p">)</span>
    <span class="c1"># 结果应当趋近1
</span>    <span class="k">print</span><span class="p">(</span><span class="n">decision</span><span class="p">)</span>
    <span class="c1"># 重新生成随机值，生成一组图片保存
</span>    <span class="n">seed</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">([</span><span class="n">num_examples_to_generate</span><span class="p">,</span> <span class="n">noise_dim</span><span class="p">])</span>
    <span class="n">generate_and_save_images</span><span class="p">(</span>
            <span class="n">generator</span><span class="p">,</span>
            <span class="mi">9999</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">)</span>
</code></pre></div></div>
<p>程序经过100次迭代，最终生成的的图片类似这个样子：<br />
<img src="/attachments/201904/tensorFlow2/gan-output-100.png" alt="" /><br />
还是老话，看起来的确一般，但应当说已经有一些神似真实的样本了。</p>

<p>而把完整的训练过程连续起来作为一张动图，同VAE一样，是一幅从噪声到清晰，缓慢的渐进过程。因为GAN网络并非直接比较图片结果，无法更直接的指出图片差距，因此在渐进过程中，能看到一些反复和跳动。这说明，在机器视觉领域GAN的可控性并不如VAE。<br />
<img src="/attachments/201904/tensorFlow2/gan-final.gif" alt="" />
在所有模型未经训练的时候，我们随机生成了一幅图片，使用辨别器进行了判断。在训练完成之后，我们再次重复这一过程。通过命令行的输出，我们可以看到类似这样的结果：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tf.Tensor<span class="o">([[</span><span class="nt">-4</span>.8871705e-05]], <span class="nv">shape</span><span class="o">=(</span>1, 1<span class="o">)</span>, <span class="nv">dtype</span><span class="o">=</span>float32<span class="o">)</span>
After training:
tf.Tensor<span class="o">([[</span><span class="nt">-1</span>.5235078]], <span class="nv">shape</span><span class="o">=(</span>1, 1<span class="o">)</span>, <span class="nv">dtype</span><span class="o">=</span>float32<span class="o">)</span>
</code></pre></div></div>
<p>一开始是一个很趋近于0的值，这是因为那张完全是噪点组成的生成图片，同真实样本图片完全没有相似点，虽然辨别模型并未训练，但这依然是很低的得分。<br />
在训练完成后，所生成的图片，从辨别器的眼中看来，已经很接近真实样本，因此我们获得了一个较高的得分。</p>

<p>GAN参考论文：<a href="https://arxiv.org/abs/1701.00160">《NIPS 2016 Tutorial: Generative Adversarial Networks&gt;</a></p>

<p>（待续…）</p>

:ET