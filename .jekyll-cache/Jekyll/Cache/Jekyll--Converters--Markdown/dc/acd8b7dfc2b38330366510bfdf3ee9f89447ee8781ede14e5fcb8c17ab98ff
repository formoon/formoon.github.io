I"l<p><img src="http://115.182.41.123/files/202008/linearAlgerbra1.jpeg" alt="" /><br />
<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></p>
<h4 id="前言">前言</h4>
<p>MATLAB一向是理工科学生的必备神器，但随着中美贸易冲突的一再升级，禁售与禁用的阴云也持续笼罩在高等学院的头顶。也许我们都应当考虑更多的途径，来辅助我们的学习和研究工作。<br />
虽然PYTHON和众多模块也属于美国技术的范围，但开源软件的自由度毕竟不是商业软件可比拟的。</p>

<p>本文是一篇入门性文章，以麻省理工学院（MIT) 18.06版本线性代数课程为例，按照学习顺序介绍PYTHON在代数运算中的基本应用。介绍PYTHON代数计算的文章非常多，但通常都是按照模块作为划分顺序，在实际应用中仍然有较多困扰。而按照代数课程学习的顺序，循序渐进，集注在最常用和最实用的功能上，比较符合典型的应用逻辑。可以用较低的门槛逐步完成PYTHON在线性代数中各项功能的学习和应用。<br />
MIT 2020版本的线性代数课程也已发布，但基本是在18.06版本上的修正。Gilbert教授的年龄已经很大，只录制了一个5节课的串讲。所以系统性还是18.06版本更为完整。<br />
很讽刺是吧，课程本身也是美国的-_-#。阿Q一下吧，就当是“师夷长技以制夷”。</p>

<p>首先给出几个相关链接：<br />
<a href="https://mitmath.github.io/1806/">MIT 18.06 Linear Algebra课程主页</a><br />
<a href="https://www.bilibili.com/video/BV1ix411f7Yp">B站完整版34讲Gilbert教授课程视频</a><br />
<a href="https://pan.baidu.com/s/1S7Glgli2JywSz5EQXgmzCw">配套第三版线性代数教材(百度网盘)</a> 提取码：uhvc<br />
最新发行的教材是第5版，建议听课时使用配套的第3版教材。课程完成后，把第5版教材作为辅助读物。不然在章节、内容方面会碰到很多困惑。</p>

<h4 id="版本选择">版本选择</h4>
<p>PYTHON版本的选择现在已经没有什么困惑了，PYTHON2停止了支持，PYTHON3现在是必选项。我是用Mac电脑，通常使用brew安装PYTHON3，每次有新版本的时候执行brew upgrade会自动升级。不使用内置的PYTHON3是为了防止安装很多扩展库的时候会有系统完整性检查导致的不兼容，不过只是跑一跑数学运算的话倒也不用担心这些。<br />
Linux各发行版则不用考虑这些，内置的PYTHON3就很好用。使用apt/yum等包管理工具升级的时候会自动完成版本维护。<br />
PYTHON在Windows/Linux/Mac等各平台上兼容性非常好，特别是在数学计算方面基本不用担心互相之间的通用问题。</p>

<p>计算模块方面则有了很多的选择，常见的有NumPy/SciPy/SymPy。<br />
其中在数值计算方面，NumPy应用非常广泛，特别是TensorFlow/PyTorch等机器学习平台也把NumPy当做默认支持之后。所以本文会把NumPy当做一个选择。<br />
在课程学习和理论研究方面，符号计算更为重要。SymPy在这方面有比较多的优势，所以本文会把SymPy当做另外一个选择。<br />
SciPy以及还有一些小众计算模块同样非常优秀，但限于篇幅，本文中只好做一些取舍。</p>

<p>在PYTHON3环境下安装NumPy/SymPy模块的方法很简单：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>numpy sympy
</code></pre></div></div>
<p>如果碰到麻烦，一般是因为网络速度造成的。特别是默认的国外软件源。修改软件源到国内的服务器会提高不少下载速度，方法是修改文件~/.pip/pip.conf，默认是没有这个文件的，要自己建立~/.pip目录和新建对应的文本文件，内容为：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>global]
<span class="nb">timeout</span> <span class="o">=</span> 6000
index-url <span class="o">=</span> https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host <span class="o">=</span> pypi.tuna.tsinghua.edu.cn
</code></pre></div></div>
<p>这里使用了清华大学的镜像服务器。<br />
以上是在Linux/Mac之上的操作方法。Windows用户，虽然PYTHON3本身没有兼容问题，但还是建议你使用Windows10内置的Linux子系统来学习。能让你节省很多时间。</p>

<h4 id="矩阵的表达">矩阵的表达</h4>
<p>在Pyhton中使用扩展库，首先要做引用，比如引入NumPy库：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
</code></pre></div></div>
<p>意思是引用numpy计算库，并重新命名为np。使用numpy中的方法时，首先要以“np.”开头。<br />
SymPy库的引用，通常会直接从中将所有资源直接引用到当前作用域，像使用原生方法一样使用SymPy中定义的方法，这也是SymPy官方推荐的：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
</code></pre></div></div>
<p>出于个人习惯，我还是更喜欢同使用NumPy一样使用SymPy:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="n">sp</span>
</code></pre></div></div>
<p>虽然因此所有的SymPy的方法都要冠以“sp.”前缀，但这样不容易造成混淆从而导致错误。</p>

<p>以下内容大致对应课程（MIT 18.06 Linear Algebra课程，以下简称课程）第1、2讲的内容。<br />
在线性代数中，主要涉及3种数据类型，常量、标量（Scalar)、向量(Vector)、矩阵（Matrix)。
无论NumPy还是SymPy，都直接使用了基本Python类型作为标量，比如：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div></div>
<p>而对于向量和矩阵，处理方法则有很大区别，下面先讲述NumPy中的方法。</p>

<p>假设我们有v1、v2两个向量，及A、B两个矩阵：</p>

\[v1 = \left[\begin{matrix}1\\2\\\end{matrix}\right]\]

\[v2 = \left[\begin{matrix}3\\4\\\end{matrix}\right]\]

\[A = \left[\begin{matrix}1&amp;2\\3&amp;4\\\end{matrix}\right]\]

\[B = \left[\begin{matrix}5&amp;6\\7&amp;8\\\end{matrix}\right]\]

<ol>
  <li>首先，NumPy接受Python原生的数组当做向量和矩阵
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 除非特别注明，我们的示例都在交互方式使用Python
# 每一行开始的“&gt;&gt;&gt;”就是交互方式下Python给出的提示符
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ac</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v1c</span>		<span class="c1">#交互方式直接给出变量名是显示变量内容的意思
</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2c</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ac</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bc</span>
<span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
</code></pre></div>    </div>
  </li>
  <li>其次，NumPy内置的数组类型（Array)也可以用来表示向量和矩阵
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>	<span class="c1">#别忘记引用numpy,以后不再特别注明
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1n</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2n</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2c</span><span class="p">)</span>	<span class="c1">#直接使用前面定义好的内部数组类型初始化向量是一样的
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">An</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bn</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">Bc</span><span class="p">)</span>	<span class="c1">#直接使用前面定义好的内部数组类型初始化矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1n</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2n</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">An</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bn</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>    </div>
  </li>
  <li>最正规的表示方法，使用NumPy内置的Matrix类型
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">([[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">Bc</span><span class="p">)</span>	<span class="c1">#使用以前定义过的内部数组类型来定义矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>    </div>
    <p>第1、2种方法，虽然在很多情况下都能正常的使用，但都算不上规范化的矩阵表示方法。特别是对于向量的表示，向量本来是纵向的，代表矩阵中的一列。但在方法1、2中，都成为了横向的。这很容易造成概念的混淆，和计算中的错误。<br />
在NumPy中，很多计算，对于内部数组及NumPy数组的处理中，也会不按照矩阵的方式处理。因此建议大家在对Python及NumPy非常熟悉之前，不要使用方法1、2中的方式来处理向量和矩阵，虽然看起来可能会方便那么一点。<br />
为了让大家对这种差异有更清晰的认识，这里举几个例子，也顺便看一看最基本的矩阵计算：</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 计算 矩阵*常量
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Ac</span><span class="o">*</span><span class="mi">3</span>	<span class="c1">#完全错误的结果，不可用
</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">An</span><span class="o">*</span><span class="mi">3</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="mi">3</span>
<span class="n">matrix</span><span class="p">([[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
     <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

 <span class="c1"># 计算 向量*常量
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1c</span><span class="o">*</span><span class="mi">3</span>	<span class="c1">#完全错误的结果，不可用
</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v1n</span><span class="o">*</span><span class="mi">3</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v1</span><span class="o">*</span><span class="mi">3</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>

 <span class="c1"># 计算向量加法
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1c</span><span class="o">+</span><span class="n">v2c</span>	<span class="c1">#完全错误的结果，不可用
</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v1n</span><span class="o">+</span><span class="n">v2n</span>
<span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v1</span><span class="o">+</span><span class="n">v2</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>

 <span class="c1"># 计算矩阵乘法
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Ac</span><span class="o">*</span><span class="n">Bc</span>	<span class="c1">#Python内部没有定义对应操作，不可用
</span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">can</span><span class="err">‘</span><span class="n">t</span> <span class="n">multiply</span> <span class="n">sequence</span> <span class="n">by</span> <span class="n">non</span><span class="o">-</span><span class="nb">int</span> <span class="n">of</span> <span class="nb">type</span> <span class="s">'list'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">An</span><span class="o">*</span><span class="n">Bn</span>	<span class="c1">#只是对应行列数字相乘，不是真正的矩阵乘法
</span><span class="n">array</span><span class="p">([[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="mi">32</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="n">B</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">43</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
</code></pre></div>    </div>
    <p>以上的示例可以明显看出，对于Python内置数组类型，并没有定义对应的矩阵操作，所以不能直接用于线性代数的计算。NumPy的很多方法都接受使用Python内部数组作为参数来表达向量和矩阵，但综合看来并没有多么方便。  <br />
NumPy内置的数组类型和矩阵类型，在简单运算中都能得到正确的结果，可以用于常用的计算。但实际上很多高级函数及算法，对两种类型的处理仍然存在很大区别，就类似示例中出现的矩阵乘法。所以在彻底了解之前，不建议使用np.array类型当做矩阵类型来使用。否则在复杂的项目中，很多莫名其妙的计算错误会让你排错工作异常复杂。</p>
  </li>
</ol>

<p>NumPy还提供了一种更方便的方法来定义向量和矩阵，这也能帮助你彻底放弃使用np.array来当做矩阵使用：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">v1</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"1;2"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"3;4"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"1 2;3 4"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"5 6;7 8"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v1</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>	<span class="c1">#sympy的Matrix定义方法太麻烦了，有的时候你会喜欢用np.mat转换过来
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">As</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div></div>
<p>熟悉MATLAB的同学应当开心了，这跟MATLAB中定义矩阵的方法完全一样，算是Python环境中最方便的方法。</p>

<p>在线性代数课程中，经常会需要选取一个典型矩阵，做一些计算的练习。课堂上Gilbert教授经常随手就可以举出一个矩阵的例子，并且各行列线性无关，而我们往往很难做到这一点。这时候可以使用随机数初始化矩阵的方法：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">C</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>	<span class="c1">#使用随机数初始化一个3x3矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">C</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.58896997</span><span class="p">,</span> <span class="mf">0.45879526</span><span class="p">,</span> <span class="mf">0.34384609</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.78480365</span><span class="p">,</span> <span class="mf">0.19043321</span><span class="p">,</span> <span class="mf">0.69538183</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.66016878</span><span class="p">,</span> <span class="mf">0.81037627</span><span class="p">,</span> <span class="mf">0.75616191</span><span class="p">]])</span>
	<span class="c1">#也可以选择整数的版本，第一个参数100的意思是产生1-100的随机数 
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">51</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">75</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">20</span><span class="p">]])</span>
</code></pre></div></div>
<p>与此类似的，还有初始化一个全0矩阵、全1矩阵、单位方阵I的方法，如果你打算用程序逻辑建立一个矩阵，那这些往往是开始的第一步：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	#定义并初始化一个全0矩阵，第一个参数为维度形状(m,n)
&gt;&gt;&gt; np.zeros((4,3))
array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
	#定义并初始化一个全1矩阵，第一个参数为维度形状(m,n)
&gt;&gt;&gt; np.ones((3,3),dtype=float)
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]])
	#定义并初始化一个单位矩阵I
&gt;&gt;&gt; np.eye(3,3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
</code></pre></div></div>
<p>下面看看SymPy定义向量、矩阵的方法。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="n">sp</span>	<span class="c1">#别忘记引入函数库，以后将不再提醒
</span>	<span class="c1">#喜欢使用from sympy import *方式的自行修改对应代码
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1s</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2s</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bs</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">Bc</span><span class="p">)</span>	<span class="c1">#使用Python内置数组当做参数初始化矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1s</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2s</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bs</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>

	<span class="c1"># 基本运算示例
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">v1s</span><span class="o">+</span><span class="n">v2s</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">4</span><span class="p">],</span>
<span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">*</span><span class="n">Bs</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
<span class="p">[</span><span class="mi">43</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">*</span><span class="mi">3</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
<span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

	<span class="c1"># sympy定义并初始化一个随机矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">sp</span><span class="p">.</span><span class="n">randMatrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">34</span><span class="p">],</span>
<span class="p">[</span><span class="mi">33</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">96</span><span class="p">]])</span>
	<span class="c1"># 定义并初始化一个全0矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">sp</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
	<span class="c1"># 定义并初始化一个全1矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">sp</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
	<span class="c1"># 定义并初始化一个单位矩阵I
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">sp</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div>
<p>作为符号计算的代表，SymPy的计算结果通常都是公式形式，所以SymPy专门提供了LaTeX的输出方式：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">sp</span><span class="p">.</span><span class="n">latex</span><span class="p">(</span><span class="n">As</span><span class="p">)</span>
<span class="s">'</span><span class="se">\\</span><span class="s">left[</span><span class="se">\\</span><span class="s">begin{matrix}1 &amp; 2</span><span class="se">\\\\</span><span class="s">3 &amp; 4</span><span class="se">\\</span><span class="s">end{matrix}</span><span class="se">\\</span><span class="s">right]'</span>
</code></pre></div></div>
<p>这种输出格式对通常的程序没有什么意义。但如果是用于论文写作的话，可以直接拷贝到LaTex编辑器，成为一个精致的公式输出。就类似本文中的公式，通常也是采用LaTeX格式输入。</p>

<h4 id="求解线性方程">求解线性方程</h4>
<p>这也是课程第1、2讲中的内容。方程组是矩阵的起源，也是矩阵最初的目的。以课程中的方程组为例：</p>

\[\left\{
    \begin{array}{l}
2x-y=0\\
-x+2y=3
        \end{array}
\right.\]

<p>可以得到矩阵A及向量b:</p>

\[A = \left[\begin{matrix}2&amp;-1\\-1&amp;2\\\end{matrix}\right]\]

\[b = \left[\begin{matrix}0\\3\\\end{matrix}\right]\]

\[Ax=b\]

<p>这里的x实际代表两个未知数组成的向量：</p>

\[x = \left[\begin{matrix}x\\y\\\end{matrix}\right]\]

<p>使用NumPy解方程组示例：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"2 -1;-1 2"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"0;3"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">],</span>	<span class="c1">#未知数x
</span>        <span class="p">[</span><span class="mf">2.</span><span class="p">]])</span>	<span class="c1">#未知数y
</span></code></pre></div></div>
<p>使用SymPy解方程组示例：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">.</span><span class="n">LDLsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</code></pre></div></div>
<p>作为符号计算的优势，SymPy中可以定义未知数符号之后，再使用跟NumPy中同名的方法solve()来直接对一个方程组求解，但那个不属于本文的主题范畴，所以不做介绍。有兴趣的话也可以参考这篇老博文<a href="http://blog.17study.com.cn/2018/12/28/python3-lesson11/">《从零开始学习PYTHON3讲义（十一）》</a>。<br />
SymPy跟NumPy在使用中语法差异还是比较大的，使用中需要特别注意。两个软件包，虽然都是Python中的实现，但并不是由同一支开发团队完成的。所以这种差异感始终是存在的。</p>

<h4 id="矩阵乘法和逆矩阵">矩阵乘法和逆矩阵</h4>
<p>这是课程第三讲的内容，其中矩阵同矩阵的乘法运算在前面一开始就演示过了，对于手工计算来讲，这是最繁琐的部分。而对于Python,这是最简单的部分。<br />
矩阵的逆在线性代数中会频繁出现，经常用到，两个软件包中都已经有了内置的方法。</p>

<p>下面在同一个代码块中分别演示NumPy和SymPy的方法：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c1">#numpy矩阵定义及矩阵乘法
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"1 2;3 4"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"5 6;7 8"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="n">B</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">43</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
	<span class="c1">#sympy矩阵定义及矩阵乘法
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Bs</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">*</span><span class="n">Bs</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
<span class="p">[</span><span class="mi">43</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">*</span><span class="n">Bs</span>	<span class="c1">#numpy的矩阵*sympy矩阵，两个软件包的变量是可以相互通用的，但通常尽量不这样做
</span><span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
<span class="p">[</span><span class="mi">43</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
	<span class="c1"># numpy求逆
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>	<span class="c1">#数值计算会尽量求得精确小数
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>		<span class="c1">#使用求幂的方式获得逆矩阵，**是Python内置的求幂运算符，numpy做了重载
</span><span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">#numpy中的求幂函数
</span><span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>

	<span class="c1"># sympy求逆
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="p">.</span><span class="n">inv</span><span class="p">()</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>    <span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>	<span class="c1">#符号计算会保持分数形式
</span>
	<span class="c1">#numpy也可以从sympy的计算结果中，获取计算数值，通常，这能提供更高的精度
</span>	<span class="c1">#当然，sympy并不以速度见长
</span>	<span class="c1">#后面的参数是将结果转换为浮点数，否则sympy数据会当做对象存储在numpy矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">As</span><span class="p">.</span><span class="n">inv</span><span class="p">(),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>

	<span class="c1">#sympy中使用求幂的方式获得逆矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">As</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>	<span class="c1">#sympy所重载的求幂运算符
</span><span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>    <span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="p">.</span><span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">#sympy标准的求幂函数
</span><span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>    <span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>

	<span class="c1"># 分别证明A的逆*A=单位矩阵I
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">A</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mf">1.00000000e+00</span><span class="p">,</span> <span class="mf">0.00000000e+00</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.11022302e-16</span><span class="p">,</span> <span class="mf">1.00000000e+00</span><span class="p">]])</span>	<span class="c1">#注意左边的值e-16,是一个很接近0的小数
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">*</span><span class="n">As</span><span class="p">.</span><span class="n">inv</span><span class="p">()</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>	<span class="c1">#符号计算通常能精确的还原应有的整数
</span></code></pre></div></div>
<p>上面代码非常明显的体现出了NumPy数值计算和SymPy符号计算的不同。前者会因精度所限有极小的误差，而后者通常能保持美观的整数数字。但前者的数字可以直接应用到机器学习等业务系统。而后者是对人的理解更有益，归根结底还是符号，不能当做数值使用。<br />
好在Python之中，如果不考虑转换速度，不同模块之间共享数据非常容易。前面的演示中已经有了将NumPy矩阵转换为SymPy矩阵，以及将SymPy的计算结果转换到NumPy的实例。这对用户来说，是非常方便的。</p>

<h4 id="矩阵的lu分解">矩阵的LU分解</h4>
<p>课程第四讲重点讲解了矩阵的LU分解。对于一个给定矩阵A,可以表现为一个下三角矩阵和一个上三角矩阵乘积的形式：</p>

\[A=LU\]

<p>其中上三角矩阵U是求解方程组的初步中间产物。由这一步开始，逐步求解靠后的主元，再回代至方程，以求解更多的未知数主元。重复这个步骤，直到完成所有未知数的求解。<br />
NumPy中，并没有提供矩阵的LU分解功能。可能是因为觉得L、U矩阵用途并不是那么广泛，并且可以直接用方程求解来替代。<br />
如果需要用到的话，通常发方式是使用其它软件包替代，比如SciPy。<br />
这里也提供一个架构于NumPy之上的子程序，来完成LU分解功能：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">LUdecomposition</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">])</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span><span class="c1">#U
</span>                <span class="n">temp</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">+</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">temp</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span><span class="c1">#L
</span>                <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="p">):</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">)</span><span class="o">/</span><span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>

<span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"1 2;3 4"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">LUdecomposition</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
	<span class="c1">#输出内容
</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]),</span> <span class="n">matrix</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">]]))</span>
</code></pre></div></div>
<p>偏重于计算分析的SymPy则直接内置了LU分解功能，对速度不敏感的场合，使用SymPy做LU分解，再转换到NumPy矩阵也是一个好办法：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">As</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="s">"1 2;3 4"</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">As</span><span class="p">.</span><span class="n">LUdecomposition</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span>
<span class="n">Matrix</span><span class="p">([</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
</code></pre></div></div>
<p>使用下划线忽略的部分是函数放回的行交换矩阵。<br />
在消元过程中，对应主元位置如果为0的话会导致消元失败，此时会产生行交换。这种情况下，会由单位矩阵I变换而来的行交换矩阵先同矩阵A相乘，从而将主元为0的行交换到其它行，保证消元的顺利进行。<br />
使用Python辅助解方程，这些步骤都是很少需要手工操作了，如果有必要，就自行赋值给矩阵变量保留吧。</p>

:ET